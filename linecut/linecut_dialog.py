# -*- coding: utf-8 -*-
"""
/***************************************************************************
 linecutDialog
                                 A QGIS plugin
 Allows user to draw line and then cuts the polygons which intersect with that line into two parts
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-17
        git sha              : $Format:%H$
        copyright            : (C) 2024 by sk
        email                : shreyas.08kat@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from .psql import *

import psycopg2
import os
import qgis.utils
import qgis

from PyQt5.QtGui import QColor
from PyQt5 import QtCore
from PyQt5.QtCore import QPointF, Qt
from qgis.PyQt import uic, QtWidgets

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFeature,
    QgsLineSymbol,
    QgsGeometry,
    QgsSingleSymbolRenderer,
    QgsFillSymbol,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsField,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsPointXY,
    QgsAnnotation,
    QgsCoordinateReferenceSystem,
    QgsTextAnnotation,
    QgsRuleBasedRenderer
)
from PyQt5.QtCore import pyqtSignal
from qgis.gui import QgsMapCanvasAnnotationItem, QgsMapToolEmitPoint, QgsRubberBand
from qgis.gui import QgsMapToolEmitPoint
from PyQt5.QtGui import QColor, QTextDocument
from PyQt5.QtCore import QSizeF, QPointF, Qt
from qgis.PyQt.QtCore import QVariant 
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QDockWidget
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'linecut_dialog_base.ui'))


#------------------------------------------------------------------------------#

class LineDrawTool(QgsMapToolEmitPoint):
    
    line_drawn = pyqtSignal()
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.rubberBand = None
        self.points = []
        self.line = None
        super(LineDrawTool, self).__init__(self.canvas)

    def canvasPressEvent(self, e):
        # Start a new line at the clicked point
        self.points = [self.toMapCoordinates(e.pos())]
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(2)
        self.rubberBand.addPoint(self.points[0])

    def canvasMoveEvent(self, e):
        # Update the end point of the line as the mouse is moved
        if self.rubberBand:
            self.rubberBand.movePoint(self.toMapCoordinates(e.pos()))

    def canvasReleaseEvent(self, e):
        # Add the point to the line when the mouse button is released
        if self.rubberBand:
            if len(self.points) <= 2:
                self.points.append(self.toMapCoordinates(e.pos()))
                self.rubberBand.addPoint(self.points[-1])
                self.line = self.rubberBand.asGeometry()
                self.canvas.unsetMapTool(self)
                self.line_drawn.emit()

    
        

#------------------------------------------------------------------------------#

class linecutDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None ):
        """Constructor."""
        super(linecutDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.line = None
        self.points = []
        self.ok_button.accepted.connect(self.load_map)
        self.polytocut = []
        QgsProject.instance().layerWillBeRemoved.connect(self.remove_line)
        
    def load_map(self):
        village = self.village_in.text()
        map = self.map_in.text()
        original_layer = QgsVectorLayer(
            f"dbname='{psql['database']}' host={psql['host']} port={psql['port']} user='{psql['user']}' password='{psql['password']}' sslmode=disable key='unique_id' srid=32643 type=Polygon table=\"{village}\".\"{map}\" (geom)",
            f"{village}.{map}_colored",
            "postgres"
        )

        if not original_layer.isValid():
            print("Layer failed to load!")
        else:
            # Create a memory layer that is a copy of the original layer
            layer = QgsVectorLayer("Polygon?crs=epsg:32643", "temporary_layer", "memory")
            data_provider = layer.dataProvider()
            data_provider.addAttributes(original_layer.fields())
            layer.updateFields()
            for feature in original_layer.getFeatures():
                data_provider.addFeature(feature)

            self.layer = layer
            QgsProject.instance().addMapLayer(layer)
            self.draw_line()
            
    def draw_line(self):
        self.line_tool = LineDrawTool(self.iface.mapCanvas())
        self.line_tool.line_drawn.connect(self.select_poly)
        self.iface.mapCanvas().setMapTool(self.line_tool)
        
    def select_poly(self):
        # layer = self.iface.mapCanvas().currentLayer()
        layer = self.layer
        line = self.line_tool.line
        self.line = line
        self.points = self.line_tool.points
        request = QgsFeatureRequest().setFilterRect(line.boundingBox())
        
        for feature in layer.getFeatures(request):
            if feature.geometry().intersects(line):
                layer.select(feature.id())
                self.polytocut.append(feature.id())

        self.cut_poly()
        
    def cut_poly(self):
        # layer = self.iface.mapCanvas().currentLayer()
        layer = self.layer
        line = self.line
        points = self.points
        layer.startEditing()

        for feature_id in self.polytocut:
            feature = layer.getFeature(feature_id)
            print(f"Attempting to split feature ID {feature_id}, gid {feature.attribute('gid')} with geometry {feature.geometry().asWkt()} using line {line.asWkt()}")
            geom = feature.geometry()
            result, new_geometries, _ = geom.splitGeometry(line.asPolyline(), False)
            
            if result == 0:
                self.visualize_geom_and_line(new_geometries[0], points)
                self.visualize_geom_and_line(geom, points)
                new_geometries.append(geom)
                
            else:
                print("Split failed")
                continue

            print(f"Number of new geometries: {len(new_geometries)}")
            if len(new_geometries) != 2:
                print("Unexpected number of geometries after split. Expected 2.")
                continue
            layer.deleteFeature(feature_id)
            # Add the new polygons
            for new_geometry in new_geometries:
                new_feature = QgsFeature()
                new_feature.setGeometry(new_geometry)
                new_feature.setAttributes(feature.attributes())
                layer.addFeature(new_feature)

        # Commit the changes
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
        
    def remove_line(self):
        if self.line_tool and self.line_tool.rubberBand:
            self.line_tool.rubberBand.reset(QgsWkbTypes.LineGeometry)
# ----------------------------------------------------------------- #
        
    def visualize_geom_and_line(self, polygon_geom, line_points):
        # Create a temporary memory layer for visualization
        vl = QgsVectorLayer("Polygon?crs=EPSG:32643", "temp_layer2", "memory")
        pr = vl.dataProvider()

        # Add a field to store feature IDs
        pr.addAttributes([QgsField("ID", QVariant.Int)])

        # Create features for the polygon and line segment
        polygon_feature = QgsFeature()
        polygon_feature.setGeometry(polygon_geom)
        polygon_feature.setAttributes([1])
        pr.addFeatures([polygon_feature])

        line_geom = QgsGeometry.fromPolylineXY([line_points[0], line_points[1]])
        line_feature = QgsFeature()
        line_feature.setGeometry(line_geom)
        line_feature.setAttributes([2])
        pr.addFeatures([line_feature])
        # Add the layer to the map canvas
        QgsProject.instance().addMapLayer(vl)

        # Refresh the map canvas
        self.iface.mapCanvas().refresh()
