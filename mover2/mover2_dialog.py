# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mover2Dialog
                                 A QGIS plugin
 mover2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-06-10
        git sha              : $Format:%H$
        copyright            : (C) 2024 by sk
        email                : shreyas.08kat@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import os

from qgis._gui import QgsMapMouseEvent
from .psql import *


import psycopg2
import os
import qgis.utils
import qgis

from PyQt5.QtGui import QColor
from PyQt5 import QtCore
from PyQt5.QtCore import QPointF, Qt
from qgis.PyQt import uic, QtWidgets

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFeature,
    QgsLineSymbol,
    QgsGeometry,
    QgsSingleSymbolRenderer,
    QgsFillSymbol,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsField,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsPointXY,
    QgsAnnotation,
    QgsCoordinateReferenceSystem,
    QgsTextAnnotation,
    QgsRuleBasedRenderer
)
from qgis.core import QgsVectorFileWriter, QgsDataSourceUri
from PyQt5.QtCore import pyqtSignal
from qgis.gui import QgsMapCanvasAnnotationItem, QgsMapToolEmitPoint, QgsRubberBand, QgsMapTool
from qgis.gui import QgsMapToolEmitPoint
from PyQt5.QtGui import QColor, QTextDocument, QFont
from PyQt5.QtCore import QSizeF, QPointF, Qt
from qgis.PyQt.QtCore import QVariant 
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QDockWidget, QMessageBox, QAction, QFormLayout, QLabel, QPushButton, QRadioButton


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mover2_dialog_base.ui'))


class mover2Dialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(mover2Dialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.side_bar = None
        self.hide = True
        self.param_selected = 'farm_rating'
        self.history_vertices = []
        self.new_vertices = []
        self.is_corner = {}
        self.rubber_bands = []
        self.points_to_transform = []
        
        self.ratingLabel.hide()
        self.ratingCombo.hide()
        self.defaultLabel.hide()
        self.mapCombo.addItems(['survey_georeferenced', 'shifted_faces', 'jitter_spline_output_regularised_05', 'jitter_spline_output_regularised_03', 'farm_graph_faces'])
        self.ratingCombo.addItems(['worst_3_avg', 'all_avg'])
        self.ratingCombo.setCurrentText('worst_3_avg')
        self.showButton.clicked.connect(self.show_hide)
        self.ok_button.accepted.connect(self.initiate)
        
        
        QgsProject.instance().layerWillBeRemoved.connect(self.clean_up)
    def initiate(self):
        self.map = self.mapCombo.currentText()
        self.village = self.village_in.text()
        self.farmplots = "farmplots"
        self.corner_nodes = "corner_nodes"
        self.method = self.ratingCombo.currentText()

        if self.side_bar is None:
            self.side_bar = SideBar(self)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.side_bar)

        self.load_map()
    
    def show_hide(self):
        if self.hide:
            self.ratingLabel.show()
            self.ratingCombo.show()
            self.defaultLabel.show()
            self.hide = False
        else:
            self.ratingLabel.hide()
            self.ratingCombo.hide()
            self.defaultLabel.hide()
            self.hide = True    
        
      
    def load_map(self):
        village = self.village
        map = self.farmplots
        print("Loading Farmplots")
        layer = QgsVectorLayer(
                        f"dbname='{psql['database']}' host={psql['host']} port={psql['port']} user='{psql['user']}' password='{psql['password']}' sslmode=disable key='unique_id' srid=32643 type=Polygon table=\"{village}\".\"{map}\" (geom)",
                        f"{map}",
                        "postgres"
                    )
        if not layer.isValid():
            print("Farmplots failed to load!")
        else :
            self.farmplots_layer = layer
            symbol = QgsFillSymbol.createSimple({'color': 'green'})
            symbol.setOpacity(0.3)
            renderer = QgsSingleSymbolRenderer(symbol)
            layer.setRenderer(renderer)
            layer.triggerRepaint()
            QgsProject.instance().addMapLayer(layer)
            
            
        print("Loading Map")
        village = self.village
        map =  self.map
        original_layer = QgsVectorLayer(
            f"dbname='{psql['database']}' host={psql['host']} port={psql['port']} user='{psql['user']}' password='{psql['password']}' sslmode=disable key='unique_id' srid=32643 type=Polygon table=\"{village}\".\"{map}\" (geom)",
            f"{village}.{map}_colored",
            "postgres"
        )

        if not original_layer.isValid():
            print("Layer failed to load!")
        else:
            layer = QgsVectorLayer("Polygon?crs=epsg:32643", "temporary_layer", "memory")
            data_provider = layer.dataProvider()
            data_provider.addAttributes(original_layer.fields())
            layer.updateFields()
            for feature in original_layer.getFeatures():
                data_provider.addFeature(feature)

            self.layer = layer
            symbol = QgsFillSymbol.createSimple({'color': QColor(0,0,0,0), 'outline_color': QColor('#3579b1'), 'outline_width': '1'})
            renderer = QgsSingleSymbolRenderer(symbol)
            layer.setRenderer(renderer)
            layer.triggerRepaint()
            self.vertexselector = VertexSelector(self.canvas, self.layer)
            self.mover = NewVertex(self.canvas, self.layer)
            QgsProject.instance().addMapLayer(layer)
            self.display_rating(self.layer, self.param_selected)
            
        map = self.corner_nodes
        original_layer = QgsVectorLayer(
            f"dbname='{psql['database']}' host={psql['host']} port={psql['port']} user='{psql['user']}' password='{psql['password']}' sslmode=disable key='unique_id' srid=32643 type=Point table=\"{village}\".\"{map}\" (geom)",
            f"{village}.{map}_colored",
            "postgres"
        )

        if not original_layer.isValid():
            print("Layer failed to load!")
        else:
            self.corner_nodes_layer = original_layer
            
        
    def select_vertex(self):
        self.canvas.setMapTool(self.vertexselector)
        self.vertexselector.finished.connect(self.after_selection)

    def after_selection(self):
        self.canvas.unsetMapTool(self.vertexselector)
        print("Selected Vertex : ", self.vertexselector.selected_vertex)
        features = self.layer.getFeatures()
        self.ids_to_select = []
        self.features_of_concern = []
        
        
        for feature in features:
            geom = feature.geometry()
            for vertex in geom.vertices():
                if QgsPointXY(vertex.x(), vertex.y()) == self.vertexselector.selected_vertex:
                    self.ids_to_select.append(feature.id())
                    self.features_of_concern.append(feature)
                    break
        
        print("Selected Features : ", self.ids_to_select)
        self.neighbour_vertices()
        
    def move_vertex(self):
        self.canvas.setMapTool(self.mover)
        self.mover.finished.connect(self.after_new_vertex)
        
    def after_new_vertex(self):
        self.canvas.unsetMapTool(self.mover)
        self.layer.startEditing()
        self.new_vertices.append(self.mover.newvertex)
        self.history_vertices.append(self.vertexselector.selected_vertex)
        for feature in self.features_of_concern:
            geom = feature.geometry()
            new_vertices = []
            for vertex in geom.vertices():
                if QgsPointXY(vertex.x(), vertex.y()) == self.vertexselector.selected_vertex:
                    new_vertices.append(QgsPointXY(self.mover.newvertex.x(), self.mover.newvertex.y()))
                elif vertex in self.points_to_transform:
                    print("Hmmm")
                    new_vertices.append(self.transform(QgsPointXY(vertex.x(), vertex.y())))
                
                else:
                    new_vertices.append(QgsPointXY(vertex.x(), vertex.y()))
            
            new_geom = QgsGeometry.fromPolygonXY([new_vertices])
            feature.setGeometry(new_geom)
            new_farmrating = self.calculate_farmrating(feature, self.method)
            feature.setAttribute('farm_rating', new_farmrating)
            self.layer.updateFeature(feature)
                
        self.layer.commitChanges()
        self.canvas.refresh()
        self.display_rating(self.layer, self.param_selected)
        
        
    def calculate_farmrating(self, feature, method):
        if method == 'all_avg':
            geom_a = feature.geometry()
            ratings = []
            features = self.farmplots_layer.getFeatures()
            for farmplot_feature in features:
                geom_b = farmplot_feature.geometry()

                if geom_a.buffer(20, 5).intersects(geom_b):
                    intersection = geom_a.intersection(geom_b)
                    difference = geom_b.difference(geom_a)

                    intersection_area = intersection.area()
                    difference_area = difference.area()
                    geom_b_area = geom_b.area()

                    rating = max(intersection_area, difference_area) / geom_b_area
                    ratings.append(rating)

            if ratings:
                return sum(ratings) / len(ratings)
            else:
                return 0.0
        
        elif method == 'worst_3_avg':
            geom_a = feature.geometry()
            ratings = []
            features = self.farmplots_layer.getFeatures()
            for farmplot_feature in features:
                geom_b = farmplot_feature.geometry()

                if geom_a.buffer(20, 5).intersects(geom_b):
                    intersection = geom_a.intersection(geom_b)
                    difference = geom_b.difference(geom_a)

                    intersection_area = intersection.area()
                    difference_area = difference.area()
                    geom_b_area = geom_b.area()

                    rating = max(intersection_area, difference_area) / geom_b_area
                    ratings.append(rating)

            if ratings:
                ratings.sort()
                return sum(ratings[:3]) / 3
            else:
                return 0.0
    
    
    def clean_up(self, layer_id):
        if self.layer is not None and self.layer.id() == layer_id:
            
            self.vertexselector.clearHighlight()
            self.mover.clearHighlight()
            
            
            if self.side_bar is not None:
                self.iface.removeDockWidget(self.side_bar)
                self.side_bar.deleteLater()
                self.side_bar = None

            self.layer = None
            self.vertexselector = None
            self.mover = None
    
            for rb in self.rubber_bands:
                self.canvas.scene().removeItem(rb)
            self.rubber_bands = []
    
    def display_rating(self, layer, field):
        self.param_selected = field
        layer.setLabelsEnabled(True)

        provider = QgsPalLayerSettings()
        provider.fieldName = field
        provider.placement = QgsPalLayerSettings.Horizontal

        layer.setLabeling(QgsVectorLayerSimpleLabeling(provider))
        layer.triggerRepaint()
        
    def undo(self):
        if len(self.history_vertices) == 0:
            return

        print("Undoing")
        print(len(self.history_vertices), len(self.new_vertices))
        old_vertex = self.history_vertices.pop()
        new_vertex = self.new_vertices.pop()
        self.layer.startEditing()
        features = self.layer.getFeatures()
        features_changing = []
        for feature in features:
            geom = feature.geometry()
            for vertex in geom.vertices():
                if QgsPointXY(vertex.x(), vertex.y()) == new_vertex:
                    features_changing.append(feature)
                    break
        
        for feature in features_changing:
            geom = feature.geometry()
            new_vertices = []
            for vertex in geom.vertices():
                if QgsPointXY(vertex.x(), vertex.y()) == new_vertex:
                    new_vertices.append(QgsPointXY(old_vertex.x(), old_vertex.y()))
                else:
                    new_vertices.append(QgsPointXY(vertex.x(), vertex.y()))
            
            new_geom = QgsGeometry.fromPolygonXY([new_vertices])
            feature.setGeometry(new_geom)
            new_farmrating = self.calculate_farmrating(feature, self.method)
            feature.setAttribute('farm_rating', new_farmrating)
            self.layer.updateFeature(feature)
        
        self.layer.commitChanges()
        self.canvas.refresh()
        self.display_rating(self.layer, self.param_selected)

    def generate_heatmap(self, attribute):
        print("generating heatmap")
        layer = self.layer
        field = attribute
        if field == "farm_rating":
            colors = [(0.0, QColor('#d7191c')), (0.8, QColor('#ffffc0')), (0.9, QColor('#1a9641')), (1.0, QColor('blue'))]
        
        elif field == "actual_area_diff":
            colors = [(-100000, QColor('#ca0020')), (-0.05, QColor('#ec846e')), (-0.03, QColor('#f6d6c8')), (-0.01, QColor('#d3d3d3')), (0.01, QColor('#cfe3ed')), (0.03, QColor('#76b4d5')), (0.05, QColor('#0571b0')), (100000, QColor('blue'))]
        ranges = []
        for i in range(len(colors) - 1):
            symbol = QgsSymbol.defaultSymbol(layer.geometryType())
            symbol.setColor(colors[i][1])
            rng = QgsRendererRange(colors[i][0], colors[i+1][0], symbol, f"{100*colors[i][0]} - {100*colors[i+1][0]}")
            ranges.append(rng)

        renderer = QgsGraduatedSymbolRenderer(field, ranges)
        layer.setRenderer(renderer)

        layer.triggerRepaint()
        self.iface.layerTreeView().refreshLayerSymbology(layer.id())
        
    def remove_heatmap(self):
        print("removing heatmap")
        layer = self.layer
        symbol = QgsFillSymbol.createSimple({'color': QColor(0,0,0,0), 'outline_color': QColor('#3579b1'), 'outline_width': '1'})
        layer.setRenderer(QgsSingleSymbolRenderer(symbol))
        layer.triggerRepaint()
        self.iface.layerTreeView().refreshLayerSymbology(layer.id())

    def corners(self):
        print("hello")
        for feature in self.corner_nodes_layer.getFeatures():
            geom = feature.geometry()
            point = geom.asPoint()
            tup = (point.x(), point.y())
            self.is_corner[tup] = True
            print("Corner : ", point.x(), point.y())
    
    def neighbour_vertices(self):
        self.corners()
        features = self.features_of_concern
        geoms = []
        for feature in features:
            vertices = feature.geometry().vertices()
            ind = 0
            vertex_list = [vertex for vertex in vertices]
            n = len(vertex_list)
            for vertex in vertex_list:
                if QgsPointXY(vertex.x(), vertex.y()) == self.vertexselector.selected_vertex:
                    break
                ind += 1
                
            i = (ind + 1)%n
            j = (ind - 1 + n)%n
            while i != ind:
                point_xy = QgsPointXY(vertex_list[i].x(), vertex_list[i].y())
                if self.is_corner.get((point_xy.x(), point_xy.y())) is not None:
                    geom = QgsGeometry.fromPointXY(point_xy)
                    geoms.append(geom)
                    break
                else:
                    if vertex_list[i] not in self.points_to_transform:
                        self.points_to_transform.append(vertex_list[i])
                    i = (i + 1)%n
                
            
            while j != ind:
                point_xy = QgsPointXY(vertex_list[i].x(), vertex_list[i].y())
                if self.is_corner.get((point_xy.x(), point_xy.y())) is not None:
                    geom = QgsGeometry.fromPointXY(point_xy)
                    if geom not in geoms:
                        geoms.append(geom)
                    break
                else:
                    if vertex_list[i] not in self.points_to_transform:
                        self.points_to_transform.append(vertex_list[i])
                    j = (j - 1 + n)%n
                
            print("neighbours : ", len(geoms))
            
            
        for geom in geoms:
            rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
            rubberBand.setToGeometry(geom, self.layer)
            rubberBand.setColor(Qt.yellow)
            rubberBand.setWidth(10)
            self.rubber_bands.append(rubberBand)
        
        for point in self.points_to_transform:
            point_xy = QgsPointXY(point.x(), point.y())
            rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
            rubberBand.setToGeometry(QgsGeometry.fromPointXY(point_xy), self.layer)
            rubberBand.setColor(Qt.green)
            rubberBand.setWidth(10)
            self.rubber_bands.append(rubberBand)

    def transform(self, point):
        dx = self.mover.newvertex.x() - self.vertexselector.selected_vertex.x()
        dy = self.mover.newvertex.y() - self.vertexselector.selected_vertex.y()
        point_transformed = QgsPointXY(point.x() + dx, point.y() + dy)
        return point_transformed
#_______________________________________________________________________________________________________________________


class SideBar(QDockWidget):
    def __init__(self, parent):
        super(SideBar, self).__init__(parent)
        self.parent = parent
        form_layout = QFormLayout()
        label1 = QLabel("Hello")
        label1.setFont(QFont("Helvetica", 20))
        label2 = QLabel("Select Parameter to display")
        label2.setFont(QFont("Helvetica", 20))
        label3 = QLabel("Generate Heatmap")
        label3.setFont(QFont("Helvetica", 20))
        
        parameter1 = QRadioButton("Farm Rating")
        parameter2 = QRadioButton("Actual Area")
        parameter3 = QRadioButton("Actual Area Difference")
        parameter4 = QRadioButton("Excess Area")
        
        
        action1 = QPushButton("Select Vertex")
        action2 = QPushButton("New Vertex")
        action1.setFont(QFont("Helvetica", 15))
        action2.setFont(QFont("Helvetica", 15))
        action1.clicked.connect(parent.select_vertex)
        action2.clicked.connect(parent.move_vertex)
        
        undo = QPushButton("Undo")
        undo.setFont(QFont("Helvetica", 15))
        undo.clicked.connect(parent.undo)

        parameter1.setFont(QFont("Helvetica", 15))
        parameter2.setFont(QFont("Helvetica", 15))
        parameter3.setFont(QFont("Helvetica", 15))
        parameter4.setFont(QFont("Helvetica", 15))
        
        parameter1.clicked.connect(lambda: parent.display_rating(parent.layer, 'farm_rating'))
        parameter2.clicked.connect(lambda: parent.display_rating(parent.layer, 'actual_area'))
        parameter3.clicked.connect(lambda: parent.display_rating(parent.layer, 'actual_area_diff'))
        parameter4.clicked.connect(lambda: parent.display_rating(parent.layer, 'excess_area'))
    
        rating_heatmap = QCheckBox("Farm rating")
        rating_heatmap.setFont(QFont("Helvetica", 15))
        rating_heatmap.stateChanged.connect(self.rating_heatmap)
        
        
        form_layout.addRow(label1)
        form_layout.addRow(action1)
        form_layout.addRow(action2)
        form_layout.addRow(undo)
        form_layout.addRow(label2)
        form_layout.addRow(parameter1)
        form_layout.addRow(parameter2)
        form_layout.addRow(parameter3)
        form_layout.addRow(parameter4)
        form_layout.addRow(label3)
        form_layout.addRow(rating_heatmap)
        
        widget = QtWidgets.QWidget()
        widget.setLayout(form_layout)
        self.setWidget(widget)

    def rating_heatmap(self, state):
        if state == Qt.Checked:
            self.parent.generate_heatmap("farm_rating")
        else:
            self.parent.remove_heatmap()

#_______________________________________________________________________________________________________________________


class VertexSelector(QgsMapTool):
    finished = pyqtSignal()
    def __init__(self, canvas, layer):
        super().__init__(canvas)
        self.canvas = canvas
        self.layer = layer
        self.selected_vertex = None
        self.highlighted_vertex = None
        self.rubber_bands = []

    def canvasMoveEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        closest_vertex = self.findClosestVertex(point)
        if closest_vertex:
            if closest_vertex != self.highlighted_vertex:
                self.highlightVertex(closest_vertex)
                self.highlighted_vertex = closest_vertex
        else:
            self.clearHighlight()

    def canvasPressEvent(self, event):
        if self.highlighted_vertex:
            self.selected_vertex = self.highlighted_vertex
            QMessageBox.information(None, "Vertex Selected", f"Vertex at {self.selected_vertex.x()}, {self.selected_vertex.y()} selected")
            self.finished.emit()
    
    def findClosestVertex(self, point):
        closest_vertex = None
        min_dist = float('inf')
        for feature in self.layer.getFeatures():
            geom = feature.geometry()
            for vertex in geom.vertices():
                vertex_point = QgsPointXY(vertex.x(), vertex.y())
                # dist = QgsGeometry.fromPointXY(vertex_point).distance(QgsGeometry.fromPointXY(point))
                dist = vertex_point.distance(QgsPointXY(point))
                if dist < min_dist:
                    min_dist = dist
                    closest_vertex = vertex_point
        return closest_vertex

    
    def highlightVertex(self, vertex):
        self.clearHighlight()
        rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        rubberBand.setToGeometry(QgsGeometry.fromPointXY(vertex), self.layer)
        rubberBand.setColor(Qt.red)
        rubberBand.setWidth(10)
        self.rubber_bands.append(rubberBand)

    def clearHighlight(self):
        for rb in self.rubber_bands:
            self.canvas.scene().removeItem(rb)
        self.rubber_bands = []
        self.highlighted_vertex = None
        
#_______________________________________________________________________________________________________________________


class NewVertex(QgsMapTool):
    finished = pyqtSignal()
    def __init__(self, canvas, layer):
        super().__init__(canvas)
        self.canvas = canvas
        self.layer = layer
        self.newvertex = None
        self.rbs = []
        self.clearHighlight()
        
    def canvasPressEvent(self, event):
        self.newvertex = self.toMapCoordinates(event.pos())
        print("New Vertex : ", self.newvertex)
        rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.PointGeometry)
        rubberBand.setToGeometry(QgsGeometry.fromPointXY(self.newvertex), self.layer)
        rubberBand.setColor(Qt.blue)
        rubberBand.setWidth(10)
        self.rbs.append(rubberBand)
        self.finished.emit()
    
    def clearHighlight(self):
        for rb in self.rbs:
            self.canvas.scene().removeItem(rb)
        self.rbs = []
        self.newvertex = None
       