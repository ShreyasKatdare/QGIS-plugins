# -*- coding: utf-8 -*-
"""
/***************************************************************************
 farmcutterDialog
                                 A QGIS plugin
 cuts farmplots
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by sk
        email                : shreyas.08kat@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import os
from .psql import *

import psycopg2
import os
import qgis.utils
import qgis

from PyQt5.QtGui import QColor
from PyQt5 import QtCore
from PyQt5.QtCore import QPointF, Qt
from qgis.PyQt import uic, QtWidgets

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFeature,
    QgsLineSymbol,
    QgsGeometry,
    QgsSingleSymbolRenderer,
    QgsFillSymbol,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsField,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsPointXY,
    QgsAnnotation,
    QgsCoordinateReferenceSystem,
    QgsTextAnnotation,
    QgsRuleBasedRenderer,
    QgsVectorFileWriter, 
    QgsVectorLayerExporter
)
from PyQt5.QtCore import pyqtSignal
from qgis.core import QgsVectorFileWriter, QgsDataSourceUri
from qgis.gui import QgsMapCanvasAnnotationItem, QgsMapToolEmitPoint, QgsRubberBand
from PyQt5.QtGui import QColor, QTextDocument, QFont
from PyQt5.QtCore import QSizeF, QPointF, Qt
from qgis.PyQt.QtCore import QVariant
from PyQt5.QtWidgets import QFileDialog,QDialog, QMessageBox, QVBoxLayout, QCheckBox, QDockWidget, QPushButton, QLabel, QFormLayout, QRadioButton, QSpinBox

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'farmcutter_dialog_base.ui'))


class LineDrawTool(QgsMapToolEmitPoint):
    '''
    This class is used to draw a line on the map canvas
    '''
    def __init__(self, canvas, parent):
        '''
        Constructor
        '''
        self.canvas = canvas
        self.parent = parent
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(2)
        self.points = []
        self.line = None
        super(LineDrawTool, self).__init__(self.canvas)

    def canvasReleaseEvent(self, e):
        '''
        This method is called when the mouse is released
        If the left button is clicked, a point is added to the rubber band
        If the right button is clicked, the line is completed and the
        '''
        if e.button() == Qt.LeftButton:
            self.points.append(self.toMapCoordinates(e.pos()))
            self.rubberBand.addPoint(self.points[-1])
        
        else:
            self.canvas.unsetMapTool(self)
            self.line = self.rubberBand.asGeometry()
            self.parent.buffer_line(self.parent.wid)
    
    def canvasPressEvent(self, e):
        '''
        This method is called when the mouse is pressed
        If the right button is clicked, the line is completed
        '''
        if e.button() == Qt.RightButton:
            self.canvas.unsetMapTool(self)
            self.line = self.rubberBand.asGeometry()
            self.parent.buffer_line(self.parent.wid)

    def canvasMoveEvent(self, e):
        '''
        This method is called when the mouse is moved
        If the rubber band is present, it is moved to the new point
        '''
        if self.rubberBand:
            self.rubberBand.movePoint(self.toMapCoordinates(e.pos()))


class farmcutterDialog(QtWidgets.QDialog, FORM_CLASS):
    '''
    This class creates the dialog for the plugin
    '''
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(farmcutterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        '''
        Constructor
        '''
        self.setupUi(self)
        self.iface = iface
        self.lineEdit_farmplots.setText('farmplots')
        self.lineEdit_host.setText('localhost')
        self.lineEdit_port.setText('5432')
        self.lineEdit_user.setText('postgres')
        self.lineEdit_password.setText('postgres')
        self.lineEdit_database.setText('dolr')
        self.ok_button.accepted.connect(self.load_map)
        QgsProject.instance().layerWillBeRemoved.connect(self.remove_line)        

    def load_map(self):
        '''
        This method is called when the OK button is clicked
        It loads the map layer and adds it to the canvas
        '''
        self.polytocut = []
        self.line = None
        self.wid = None
        self.village = None
        self.side_bar = None
        self.maxgid = 0
        self.rubber_bands = []
        self.line_tool = None
        
        # Get the names of the village and map entered by the user from the text boxes 
        village = self.village_in.text()
        self.village = village
        self.map = self.lineEdit_farmplots.text()
        self.host = self.lineEdit_host.text()
        self.port = self.lineEdit_port.text()
        self.user = self.lineEdit_user.text()
        self.password = self.lineEdit_password.text()
        self.database = self.lineEdit_database.text()
        
        map = self.map
        original_layer = QgsVectorLayer(
            f"dbname='{self.database}' host={self.host} port={self.port} user='{self.user}' password='{self.password}' sslmode=disable key='tid' srid=32643 type=Polygon table=\"{village}\".\"{map}\" (geom)",
            f"{village}.{map}_colored",
            "postgres"
        )

        if not original_layer.isValid():
            print("Layer failed to load!")
        else:
            layer = QgsVectorLayer("Polygon?crs=epsg:32643", "temporary_layer", "memory")
            data_provider = layer.dataProvider()
            data_provider.addAttributes(original_layer.fields())
            layer.updateFields()
            for feature in original_layer.getFeatures():
                data_provider.addFeature(feature)

            self.layer = layer
            QgsProject.instance().addMapLayer(layer)
            self.side_bar = SideBar(self)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.side_bar)
            self.wid = self.side_bar.spin_box.value()
            self.psql_conn = PGConn()
            
            
    def draw_line(self):
        '''
        This method is called when the "Start Cutting" button is clicked
        It sets the map tool to LineDrawTool
        '''
        self.line_tool = LineDrawTool(self.iface.mapCanvas(), self)
        self.iface.mapCanvas().setMapTool(self.line_tool)
        
    def buffer_line(self, width):
        '''
        This method is called when the line is drawn
        It creates a buffer around the line
        '''
        for rb in self.rubber_bands:
            self.iface.mapCanvas().scene().removeItem(rb)
        self.rubber_bands = []
        line = self.line_tool.line
        self.line = line
        
        buffer = line.buffer(width, 5)
        buf = QgsFeature()
        buf.setGeometry(buffer)
        
        rubber_band = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.PolygonGeometry)
        rubber_band.setToGeometry(buffer, None)
        rubber_band.setStrokeColor(QColor(255, 0, 0))  # Red color
        rubber_band.setWidth(2)
        self.rubber_bands.append(rubber_band)
        
        self.iface.mapCanvas().refresh()
        self.iface.mapCanvas().refreshAllLayers()
        return buffer
            
    def select_poly(self):
        '''
        Selects the polygons that intersect the line and calls the cut_poly method
        '''
        layer = self.layer
        line = self.line_tool.line
        self.line = line
        
        for feature in layer.getFeatures():
            self.maxgid = max(self.maxgid, feature.attribute('gid'))
            if feature.geometry().intersects(line):
                layer.select(feature.id())
                self.polytocut.append(feature.id())

        self.cut_poly()
    
    
    def cut_poly(self):
        '''
        Cuts the selected polygons with the line buffer and adds the new polygons to the layer
        '''
        layer = self.layer
        line = self.line
        layer.startEditing()
        buffer = self.buffer_line(self.wid)
        
        for feature_id in self.polytocut:
            feature = layer.getFeature(feature_id)
            # print(f"Attempting to split feature ID {feature_id}, gid {feature.attribute('gid')} with geometry {feature.geometry().asWkt()} using line {line.asWkt()}")
            geom = feature.geometry()
            result, new_geometries, _ = geom.splitGeometry(line.asPolyline(), False)
            
            if result == 0:
                new_geometries.append(geom)
                
            else:
                print("Split failed")
                continue

            print(f"Number of new geometries: {len(new_geometries)}")
            if len(new_geometries) != 2:
                print("Unexpected number of geometries after split. Expected 2.")
                continue
            layer.deleteFeature(feature_id)
            
            newgeom1 = new_geometries[0].difference(buffer)
            if not newgeom1.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(newgeom1)
                new_feature.setAttributes(feature.attributes())
                ind = layer.fields().indexFromName('gid')
                new_feature.setAttribute(ind, self.maxgid+1)
                self.maxgid += 1
                ind = layer.fields().indexFromName('description')
                new_feature.setAttribute(ind, 'field')
                varp = self.calculate_varp(newgeom1)
                if np.isnan(varp):
                    varp = 1
                print(f"Varp is {varp}")
                ind = layer.fields().indexFromName('varp')
                new_feature.setAttribute(ind, float(varp))
                layer.addFeature(new_feature)
            
            newgeom2 = new_geometries[1].difference(buffer)
            if not newgeom2.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(newgeom2)
                new_feature.setAttributes(feature.attributes())
                ind = layer.fields().indexFromName('gid')
                new_feature.setAttribute(ind, self.maxgid+1)
                self.maxgid += 1
                ind = layer.fields().indexFromName('description')
                new_feature.setAttribute(ind, 'field')
                varp = self.calculate_varp(newgeom2)
                if np.isnan(varp):
                    varp = 1
                print(f"Varp is {varp}")
                ind = layer.fields().indexFromName('varp')
                new_feature.setAttribute(ind, float(varp))
                layer.addFeature(new_feature)
            
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
        self.remove_line()
    
    def calculate_varp(self, geom):
        '''
        :param geom: QgsGeometry object
        :return: float

        Calculates the varp parameter of the feature
        '''

        points_list = [vertex for vertex in geom.vertices()]

        points = points_list
        points.append(points_list[1])
        sum = 0
        for i in range(len(points)-2):
            a = np.array([float(points[i].x()), float(points[i].y())])
            b = np.array([float(points[i+1].x()), float(points[i+1].y())])
            c = np.array([float(points[i+2].x()), float(points[i+2].y())])

            ba = b - a
            bc = c - b
            if (np.linalg.norm(ba) * np.linalg.norm(bc)) == 0 or np.dot(ba, bc)==0:
                continue
            cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
            angle = np.arccos(min(cosine_angle,1))
            sum += abs(angle)

        varp = sum/(2*np.pi)
        
        return varp
    
    def buffer_width_changed(self):
        '''
        Every time the buffer width is changed, this method is called
        It updates the buffer around the line
        '''
        self.wid = self.side_bar.spin_box.value()
        self.buffer_line(self.wid)
    
    def remove_line(self):
        '''
        Removes the line from the canvas
        '''
        for rb in self.rubber_bands:
            self.iface.mapCanvas().scene().removeItem(rb)
        self.rubber_bands = []
        
        if self.line_tool and self.line_tool.rubberBand:
            self.iface.mapCanvas().scene().removeItem(self.line_tool.rubberBand)
            self.line_tool.rubberBand.reset(QgsWkbTypes.LineGeometry)
            
            
#______________________________________________________________________________________________


class SideBar(QDockWidget):
    '''
    This class creates the sidebar for the plugin
    '''
    def __init__(self, parent):
        '''
        Constructor
        '''
        super(SideBar, self).__init__(parent)
        self.parent = parent
        form_layout = QFormLayout()
        
        label1 = QLabel("(Use left click to draw line, right click to finish drawing)")
        label1.setFont(QFont("Helvetica", 15))
        
        empty = QLabel("")
        action1 = QPushButton("Start Cutting")
        action1.setFont(QFont("Helvetica", 15))
        action1.clicked.connect(parent.draw_line)
        
        label = QLabel("Set Width of buffer :")
        label.setFont(QFont("Helvetica", 15))
        
        self.cutbutton = QPushButton("Cut")
        self.cutbutton.setFont(QFont("Helvetica", 15))
        self.cutbutton.clicked.connect(parent.select_poly)
        
        self.spin_box = QSpinBox()
        self.spin_box.setRange(0, 100)
        self.spin_box.setSingleStep(5)
        self.spin_box.valueChanged.connect(self.buffer_changed)
        
        self.save_button = QPushButton("Save to postgres")
        self.save_button.setFont(QFont("Helvetica", 15))
        self.save_button.clicked.connect(self.save_layer_postgres)
                
        self.save_locally = QPushButton("Save Layer Locally")
        self.save_locally.setFont(QFont("Helvetica", 15))
        self.save_locally.clicked.connect(self.save_layer_locally)
        
        form_layout.addRow(action1)
        form_layout.addRow(label1)
        form_layout.addRow(empty)
        form_layout.addRow(label)
        form_layout.addRow(self.spin_box)
        form_layout.addRow(self.cutbutton)
        form_layout.addRow(self.save_button)
        form_layout.addRow(self.save_locally)
        
        
        widget = QtWidgets.QWidget()
        widget.setLayout(form_layout)
        self.setWidget(widget)
        
    def buffer_changed(self):
        '''
        This method is called when the buffer width is changed
        It calls the buffer_width_changed method of the parent
        '''
        self.parent.buffer_width_changed()
        
    def save_layer_postgres(self):
        '''
        This method is called when the "Save to Postgres" button is clicked
        It saves the layer to the Postgres database
        '''
        print("saving...")
        schema = self.parent.village
    
        if 'editing' in self.parent.map:
            table_name = self.parent.map
        else:
            table_name = f"{self.parent.map}_editing"
        print("Dropping table : ", table_name)
        drop_table(self.parent.psql_conn, schema, table_name)
        
        uri = QgsDataSourceUri()
        uri.setConnection(psql['host'], psql['port'], psql['database'], psql['user'], psql['password'])
        uri.setDataSource(schema, table_name, "geom", "", "gid")
        err = QgsVectorLayerExporter.exportLayer(self.parent.layer, uri.uri(), "postgres", QgsCoordinateReferenceSystem(), False)

        if err[0] != QgsVectorLayerExporter.NoError:
            print("Error when saving layer to Postgres: ", err)
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText(f"Failed to save layer to Postgres\nError: {err}")
            msg.setWindowTitle("Failed")
            msg.exec_()
        else:
            print("Layer saved successfully")
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText(f"Layer saved successfully\nYou will be able to see the layer named {table_name} in schema {schema}")
            msg.setWindowTitle("Success")
            msg.exec_()
            
    
    def save_layer_locally(self):
        '''
        This method is called when the "Save Layer Locally" button is clicked
        It saves the layer to the local file system
        '''
        file_name, _ = QFileDialog.getSaveFileName(self, "Save Layer", "", "Shapefile (*.shp);;GeoJSON (*.geojson)")
        print("file_name : ", file_name)
        if file_name:
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "ESRI Shapefile"
            options.fileEncoding = "UTF-8"
            transformContext = QgsProject.instance().transformContext()
            writer = QgsVectorFileWriter.writeAsVectorFormatV2(self.parent.layer, file_name, transformContext, options)
            if writer == QgsVectorFileWriter.NoError:
                print("Layer saved successfully")
            else:
                print("Error saving layer")
                
            
