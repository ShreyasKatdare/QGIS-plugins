# -*- coding: utf-8 -*-
"""
/***************************************************************************
 farmcutterDialog
                                 A QGIS plugin
 cuts farmplots
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by sk
        email                : shreyas.08kat@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import os
from .psql import *

import psycopg2
import os
import qgis.utils
import qgis

from PyQt5.QtGui import QColor
from PyQt5 import QtCore
from PyQt5.QtCore import QPointF, Qt
from qgis.PyQt import uic, QtWidgets

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFeature,
    QgsLineSymbol,
    QgsGeometry,
    QgsSingleSymbolRenderer,
    QgsFillSymbol,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsField,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsPointXY,
    QgsAnnotation,
    QgsCoordinateReferenceSystem,
    QgsTextAnnotation,
    QgsRuleBasedRenderer
)
from PyQt5.QtCore import pyqtSignal
from qgis.gui import QgsMapCanvasAnnotationItem, QgsMapToolEmitPoint, QgsRubberBand
from qgis.gui import QgsMapToolEmitPoint
from PyQt5.QtGui import QColor, QTextDocument
from PyQt5.QtCore import QSizeF, QPointF, Qt
from qgis.PyQt.QtCore import QVariant 
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QDockWidget

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'farmcutter_dialog_base.ui'))


class LineDrawTool(QgsMapToolEmitPoint):
    
    line_drawn = pyqtSignal()
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.rubberBand = None
        self.points = []
        self.line = None
        super(LineDrawTool, self).__init__(self.canvas)

    def canvasPressEvent(self, e):
        # Start a new line at the clicked point
        self.points = [self.toMapCoordinates(e.pos())]
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(2)
        self.rubberBand.addPoint(self.points[0])

    def canvasMoveEvent(self, e):
        # Update the end point of the line as the mouse is moved
        if self.rubberBand:
            self.rubberBand.movePoint(self.toMapCoordinates(e.pos()))

    def canvasReleaseEvent(self, e):
        # Add the point to the line when the mouse button is released
        if self.rubberBand:
            if len(self.points) <= 2:
                self.points.append(self.toMapCoordinates(e.pos()))
                self.rubberBand.addPoint(self.points[-1])
                self.line = self.rubberBand.asGeometry()
                self.canvas.unsetMapTool(self)
                self.line_drawn.emit()


class farmcutterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(farmcutterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.polytocut = []
        self.line = None
        self.wid = None
        self.village = None
        self.maxgid = 0
        self.map = 'farmplots'
        self.ok_button.accepted.connect(self.load_map)
        QgsProject.instance().layerWillBeRemoved.connect(self.remove_line)        

    def load_map(self):
        village = self.village_in.text()
        self.wid = int(self.width_in.text())
        self.village = village
        map = self.map
        original_layer = QgsVectorLayer(
            f"dbname='{psql['database']}' host={psql['host']} port={psql['port']} user='{psql['user']}' password='{psql['password']}' sslmode=disable key='unique_id' srid=32643 type=Polygon table=\"{village}\".\"{map}\" (geom)",
            f"{village}.{map}_colored",
            "postgres"
        )

        if not original_layer.isValid():
            print("Layer failed to load!")
        else:
            # Create a memory layer that is a copy of the original layer
            layer = QgsVectorLayer("Polygon?crs=epsg:32643", "temporary_layer", "memory")
            data_provider = layer.dataProvider()
            data_provider.addAttributes(original_layer.fields())
            layer.updateFields()
            for feature in original_layer.getFeatures():
                data_provider.addFeature(feature)

            self.layer = layer
            QgsProject.instance().addMapLayer(layer)
            self.draw_line()
            
            
    def draw_line(self):
        self.line_tool = LineDrawTool(self.iface.mapCanvas())
        self.line_tool.line_drawn.connect(self.select_poly)
        self.iface.mapCanvas().setMapTool(self.line_tool)
        
    def buffer_line(self, width):
        line = self.line_tool.line
        self.line = line
        buffer = line.buffer(width, 1)
        buf = QgsFeature()
        buf.setGeometry(buffer)
        vl = QgsVectorLayer("Polygon?crs=EPSG:32643", "buffer", "memory")
        pr = vl.dataProvider()

        # Add a field to store feature IDs
        pr.addAttributes([QgsField("ID", QVariant.Int)])

        # Create features for the polygon and line segment
        polygon_feature = QgsFeature()
        polygon_feature.setGeometry(buffer)
        polygon_feature.setAttributes([1])
        pr.addFeatures([polygon_feature])
        symbol = QgsFillSymbol.createSimple({'color':'255,0,0,100'})  # Red color with some transparency
        vl.renderer().setSymbol(symbol)
        # Add the buffer layer to the map
        QgsProject.instance().addMapLayer(vl)
        self.iface.mapCanvas().refresh()
        # self.layer.startEditing()
        # for feature in self.layer.getFeatures():
        #     geom = feature.geometry()
        #     if geom.intersects(buffer):
        #         print("yes")
        #         difference = geom.difference(buffer)
        #         feature.setGeometry(difference)
        #         self.layer.updateFeature(feature)
                
        # self.layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
        return buffer
            
    def select_poly(self):
        # layer = self.iface.mapCanvas().currentLayer()
        layer = self.layer
        line = self.line_tool.line
        self.line = line
        
        for feature in layer.getFeatures():
            self.maxgid = max(self.maxgid, feature.attribute('gid'))
            if feature.geometry().intersects(line):
                layer.select(feature.id())
                self.polytocut.append(feature.id())

        self.cut_poly()
    
    
    def cut_poly(self):
        # layer = self.iface.mapCanvas().currentLayer()
        layer = self.layer
        line = self.line
        layer.startEditing()
        buffer = self.buffer_line(self.wid)
        
        for feature_id in self.polytocut:
            feature = layer.getFeature(feature_id)
            print(f"Attempting to split feature ID {feature_id}, gid {feature.attribute('gid')} with geometry {feature.geometry().asWkt()} using line {line.asWkt()}")
            geom = feature.geometry()
            result, new_geometries, _ = geom.splitGeometry(line.asPolyline(), False)
            
            if result == 0:
                new_geometries.append(geom)
                
            else:
                print("Split failed")
                continue

            print(f"Number of new geometries: {len(new_geometries)}")
            if len(new_geometries) != 2:
                print("Unexpected number of geometries after split. Expected 2.")
                continue
            layer.deleteFeature(feature_id)
            
            newgeom1 = new_geometries[0].difference(buffer)
            if not newgeom1.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(newgeom1)
                new_feature.setAttributes(feature.attributes())
                ind = layer.fields().indexFromName('gid')
                new_feature.setAttribute(ind, self.maxgid+1)
                self.maxgid += 1
                ind = layer.fields().indexFromName('description')
                new_feature.setAttribute(ind, 'field')
                varp = self.calculate_varp(newgeom1)
                if np.isnan(varp):
                    varp = 1
                print(f"Varp is {varp}")
                ind = layer.fields().indexFromName('varp')
                new_feature.setAttribute(ind, float(varp))
                layer.addFeature(new_feature)
            
            newgeom2 = new_geometries[1].difference(buffer)
            if not newgeom2.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(newgeom2)
                new_feature.setAttributes(feature.attributes())
                ind = layer.fields().indexFromName('gid')
                new_feature.setAttribute(ind, self.maxgid+1)
                self.maxgid += 1
                ind = layer.fields().indexFromName('description')
                new_feature.setAttribute(ind, 'field')
                varp = self.calculate_varp(newgeom2)
                if np.isnan(varp):
                    varp = 1
                print(f"Varp is {varp}")
                ind = layer.fields().indexFromName('varp')
                new_feature.setAttribute(ind, float(varp))
                layer.addFeature(new_feature)
            
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
    
    def calculate_varp(self, geom):
        
        points_list = [vertex for vertex in geom.vertices()]

        points = points_list
        points.append(points_list[1])
        sum = 0
        for i in range(len(points)-2):
            a = np.array([float(points[i].x()), float(points[i].y())])
            b = np.array([float(points[i+1].x()), float(points[i+1].y())])
            c = np.array([float(points[i+2].x()), float(points[i+2].y())])

            ba = b - a
            bc = c - b
            if (np.linalg.norm(ba) * np.linalg.norm(bc)) == 0 or np.dot(ba, bc)==0:
                continue
            cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
            angle = np.arccos(min(cosine_angle,1))
            sum += abs(angle)

        varp = sum/(2*np.pi)
        
        return varp
    
    
    def remove_line(self):
        if self.line_tool and self.line_tool.rubberBand:
            self.line_tool.rubberBand.reset(QgsWkbTypes.LineGeometry)