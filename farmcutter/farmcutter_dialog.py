# -*- coding: utf-8 -*-
"""
/***************************************************************************
 farmcutterDialog
                                 A QGIS plugin
 cuts farmplots
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-23
        git sha              : $Format:%H$
        copyright            : (C) 2024 by sk
        email                : shreyas.08kat@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import numpy as np
import os
from .psql import *

import psycopg2
import os
import qgis.utils
import qgis

from PyQt5.QtGui import QColor
from PyQt5 import QtCore
from PyQt5.QtCore import QPointF, Qt
from qgis.PyQt import uic, QtWidgets

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsSymbol,
    QgsRendererRange,
    QgsGraduatedSymbolRenderer,
    QgsFeature,
    QgsLineSymbol,
    QgsGeometry,
    QgsSingleSymbolRenderer,
    QgsFillSymbol,
    QgsWkbTypes,
    QgsFeatureRequest,
    QgsField,
    QgsPalLayerSettings,
    QgsVectorLayerSimpleLabeling,
    QgsTextFormat,
    QgsTextBufferSettings,
    QgsPointXY,
    QgsAnnotation,
    QgsCoordinateReferenceSystem,
    QgsTextAnnotation,
    QgsRuleBasedRenderer
)
from PyQt5.QtCore import pyqtSignal
from qgis.gui import QgsMapCanvasAnnotationItem, QgsMapToolEmitPoint, QgsRubberBand
from PyQt5.QtGui import QColor, QTextDocument, QFont
from PyQt5.QtCore import QSizeF, QPointF, Qt
from qgis.PyQt.QtCore import QVariant
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QDockWidget, QPushButton, QLabel, QFormLayout, QRadioButton, QSpinBox

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'farmcutter_dialog_base.ui'))


class LineDrawTool(QgsMapToolEmitPoint):
        
    def __init__(self, canvas, parent):
        self.canvas = canvas
        self.parent = parent
        self.rubberBand = QgsRubberBand(self.canvas, QgsWkbTypes.LineGeometry)
        self.rubberBand.setColor(Qt.red)
        self.rubberBand.setWidth(2)
        self.points = []
        self.line = None
        super(LineDrawTool, self).__init__(self.canvas)

    def canvasReleaseEvent(self, e):
        if e.button() == Qt.LeftButton:
            self.points.append(self.toMapCoordinates(e.pos()))
            self.rubberBand.addPoint(self.points[-1])
        
        else:
            self.canvas.unsetMapTool(self)
            self.line = self.rubberBand.asGeometry()
            self.parent.buffer_line(self.parent.wid)
    
    def canvasPressEvent(self, e):
        if e.button() == Qt.RightButton:
            self.canvas.unsetMapTool(self)
            self.line = self.rubberBand.asGeometry()
            self.parent.buffer_line(self.parent.wid)

    def canvasMoveEvent(self, e):
        if self.rubberBand:
            self.rubberBand.movePoint(self.toMapCoordinates(e.pos()))


class farmcutterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(farmcutterDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.polytocut = []
        self.line = None
        self.wid = None
        self.village = None
        self.side_bar = None
        self.maxgid = 0
        self.rubber_bands = []
        
        self.map = 'farmplots'
        self.ok_button.accepted.connect(self.load_map)
        QgsProject.instance().layerWillBeRemoved.connect(self.remove_line)        

    def load_map(self):
        village = self.village_in.text()
        self.wid = int(self.width_in.text())
        self.village = village
        map = self.map
        original_layer = QgsVectorLayer(
            f"dbname='{psql['database']}' host={psql['host']} port={psql['port']} user='{psql['user']}' password='{psql['password']}' sslmode=disable key='unique_id' srid=32643 type=Polygon table=\"{village}\".\"{map}\" (geom)",
            f"{village}.{map}_colored",
            "postgres"
        )

        if not original_layer.isValid():
            print("Layer failed to load!")
        else:
            layer = QgsVectorLayer("Polygon?crs=epsg:32643", "temporary_layer", "memory")
            data_provider = layer.dataProvider()
            data_provider.addAttributes(original_layer.fields())
            layer.updateFields()
            for feature in original_layer.getFeatures():
                data_provider.addFeature(feature)

            self.layer = layer
            QgsProject.instance().addMapLayer(layer)
            # self.draw_line()
            self.side_bar = SideBar(self)
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.side_bar)
            
            
            
    def draw_line(self):
        self.line_tool = LineDrawTool(self.iface.mapCanvas(), self)
        # self.line_tool.line_drawn.connect(self.select_poly)
        self.iface.mapCanvas().setMapTool(self.line_tool)
        
    def buffer_line(self, width):
        for rb in self.rubber_bands:
            self.iface.mapCanvas().scene().removeItem(rb)
        self.rubber_bands = []
        line = self.line_tool.line
        self.line = line
        
        buffer = line.buffer(width, 5)
        buf = QgsFeature()
        buf.setGeometry(buffer)
        
        rubber_band = QgsRubberBand(self.iface.mapCanvas(), QgsWkbTypes.PolygonGeometry)
        rubber_band.setToGeometry(buffer, None)
        rubber_band.setStrokeColor(QColor(255, 0, 0))  # Red color
        rubber_band.setWidth(2)
        self.rubber_bands.append(rubber_band)
        # vl = QgsVectorLayer("Polygon?crs=EPSG:32643", "buffer", "memory")
        # pr = vl.dataProvider()

        # pr.addAttributes([QgsField("ID", QVariant.Int)])

        # polygon_feature = QgsFeature()
        # polygon_feature.setGeometry(buffer)
        # polygon_feature.setAttributes([1])
        # pr.addFeatures([polygon_feature])
        # symbol = QgsFillSymbol.createSimple({'color':'255,0,0,100'})  # Red color with some transparency
        # vl.renderer().setSymbol(symbol)
        # QgsProject.instance().addMapLayer(vl)
        
        self.iface.mapCanvas().refresh()
        self.iface.mapCanvas().refreshAllLayers()
        return buffer
            
    def select_poly(self):
        # layer = self.iface.mapCanvas().currentLayer()
        layer = self.layer
        line = self.line_tool.line
        self.line = line
        
        for feature in layer.getFeatures():
            self.maxgid = max(self.maxgid, feature.attribute('gid'))
            if feature.geometry().intersects(line):
                layer.select(feature.id())
                self.polytocut.append(feature.id())

        self.cut_poly()
    
    
    def cut_poly(self):
        # layer = self.iface.mapCanvas().currentLayer()
        layer = self.layer
        line = self.line
        layer.startEditing()
        buffer = self.buffer_line(self.wid)
        
        for feature_id in self.polytocut:
            feature = layer.getFeature(feature_id)
            # print(f"Attempting to split feature ID {feature_id}, gid {feature.attribute('gid')} with geometry {feature.geometry().asWkt()} using line {line.asWkt()}")
            geom = feature.geometry()
            result, new_geometries, _ = geom.splitGeometry(line.asPolyline(), False)
            
            if result == 0:
                new_geometries.append(geom)
                
            else:
                print("Split failed")
                continue

            print(f"Number of new geometries: {len(new_geometries)}")
            if len(new_geometries) != 2:
                print("Unexpected number of geometries after split. Expected 2.")
                continue
            layer.deleteFeature(feature_id)
            
            newgeom1 = new_geometries[0].difference(buffer)
            if not newgeom1.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(newgeom1)
                new_feature.setAttributes(feature.attributes())
                ind = layer.fields().indexFromName('gid')
                new_feature.setAttribute(ind, self.maxgid+1)
                self.maxgid += 1
                ind = layer.fields().indexFromName('description')
                new_feature.setAttribute(ind, 'field')
                varp = self.calculate_varp(newgeom1)
                if np.isnan(varp):
                    varp = 1
                print(f"Varp is {varp}")
                ind = layer.fields().indexFromName('varp')
                new_feature.setAttribute(ind, float(varp))
                layer.addFeature(new_feature)
            
            newgeom2 = new_geometries[1].difference(buffer)
            if not newgeom2.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(newgeom2)
                new_feature.setAttributes(feature.attributes())
                ind = layer.fields().indexFromName('gid')
                new_feature.setAttribute(ind, self.maxgid+1)
                self.maxgid += 1
                ind = layer.fields().indexFromName('description')
                new_feature.setAttribute(ind, 'field')
                varp = self.calculate_varp(newgeom2)
                if np.isnan(varp):
                    varp = 1
                print(f"Varp is {varp}")
                ind = layer.fields().indexFromName('varp')
                new_feature.setAttribute(ind, float(varp))
                layer.addFeature(new_feature)
            
        layer.commitChanges()
        self.iface.mapCanvas().refreshAllLayers()
    
    def calculate_varp(self, geom):
        
        points_list = [vertex for vertex in geom.vertices()]

        points = points_list
        points.append(points_list[1])
        sum = 0
        for i in range(len(points)-2):
            a = np.array([float(points[i].x()), float(points[i].y())])
            b = np.array([float(points[i+1].x()), float(points[i+1].y())])
            c = np.array([float(points[i+2].x()), float(points[i+2].y())])

            ba = b - a
            bc = c - b
            if (np.linalg.norm(ba) * np.linalg.norm(bc)) == 0 or np.dot(ba, bc)==0:
                continue
            cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
            angle = np.arccos(min(cosine_angle,1))
            sum += abs(angle)

        varp = sum/(2*np.pi)
        
        return varp
    
    def buffer_width_changed(self):
        self.wid = self.side_bar.spin_box.value()
        self.buffer_line(self.wid)
    
    def remove_line(self):
        for rb in self.rubber_bands:
            self.iface.mapCanvas().scene().removeItem(rb)
        self.rubber_bands = []
        
        if self.line_tool and self.line_tool.rubberBand:
            self.iface.mapCanvas().scene().removeItem(self.line_tool.rubberBand)
            self.line_tool.rubberBand.reset(QgsWkbTypes.LineGeometry)
            
            
#______________________________________________________________________________________________


class SideBar(QDockWidget):
    def __init__(self, parent):
        super(SideBar, self).__init__(parent)
        self.parent = parent
        form_layout = QFormLayout()
                
        action1 = QPushButton("Start Cutting")
        action1.setFont(QFont("Helvetica", 15))
        action1.clicked.connect(parent.draw_line)
        
        label = QLabel("Set Width of buffer")
        label.setFont(QFont("Helvetica", 15))
        
        self.cutbutton = QPushButton("Cut")
        self.cutbutton.setFont(QFont("Helvetica", 15))
        self.cutbutton.clicked.connect(parent.select_poly)
        
        self.spin_box = QSpinBox()
        self.spin_box.setRange(0, 100)
        self.spin_box.setSingleStep(5)
        self.spin_box.valueChanged.connect(self.buffer_changed)
        
        form_layout.addRow(action1)
        form_layout.addRow(label)
        form_layout.addRow(self.spin_box)
        form_layout.addRow(self.cutbutton)
        
        widget = QtWidgets.QWidget()
        widget.setLayout(form_layout)
        self.setWidget(widget)
        
    def buffer_changed(self):
        self.parent.buffer_width_changed()
        # TODO : Add undo, reselect line, cut buttons 
